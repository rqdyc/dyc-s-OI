# 传送门

[传送门](https://www.luogu.com.cn/problem/P3736)

# 思路

题目要求一段数**合并**后的最大分数，看到合并，且 $n$ 的范围才 $300$，自然的想到复杂度 $O(n^3)$ 的区间dp。

注意到 $k$ 的范围很小，我们就可以想到复杂度为 $O(2^k)$ 状压。

结合起来，$dp_{i,j,s}$ 表示区间 `[i,j]` 合并后状态为 $s$，显然有 $O(n^3 2^k)$ 的暴力，显然易见会超时，这时我们就要找合并的性质。

不妨假设一段长度为 $t$ 的 `01` 序列，显然易见，当 $t \gets k$ 时，合并次数为 $1$。

假设合并完一次后，得到的长度为 $1$，如果再想合并一次，就要让合并完后的长度 $1$ 加上另一端区间的长度 $t_1$ 的和为 $k$，那显然 $t_1 \gets k-1$。合并后的长度为 $1$。

然后，再合并一次，那么 $t_2 \gets k-1$。合并后的长度仍为 $1$。

显然，如果继续合并，那么会有无数个 $k-1$ 被合并，那么就有 $t_n \gets k-1$，那么能够合并为长度为 $1$ 的区间的原长度就为 $\sum_{i = 1}^{n}{t_i}+1 \to n(k-1) + 1$。

扩展一下，如果一个字符串长度为 $l_1$，合并后的长度为 $l_2$，那么根据上述方程，就有合并后的长度 $l_2 = (l_1 - 1) \bmod (k-1) + 1$。

所以dp方程就为：

$$
\begin{cases}
  dp_{i,j,2s} = \max \limits_{i \le l < j,(j - 1 - l)\mod( k - 1) = 0} \{ dp_{i,l,s} + dp_{l+1,j,0} \} \\
  dp_{i,j,(2s) \vee 1} = \max \limits_{i \le l < j,(j - 1 - l)\mod( k - 1) = 0} \{ dp_{i,l,s} + dp_{l+1,j,1} \}
\end{cases}
$$

特别的，当一段区间合并后的长度为 $1$ 时，可以将所有的状态合并为一个字符，也就是：

$$
\begin{cases}
  dp_{i,j,0} = \max \limits_{0 \le s \le 2^k-1,r_s = 0}\{dp_{i,j,s}+w_s \} \\
  dp_{i,j,1} = \max \limits_{0 \le s \le 2^k-1,r_s = 1}\{dp_{i,j,s}+w_s \} 
\end{cases}
$$

这里的 $r_s$ 表示状态为 $s$ 的字符串合并后的答案，$w_s$ 表示合并得到的分数。

# AC code

```c++
#include<bits/stdc++.h>
using namespace std;
#define ll long long
const ll N=310;
const ll K=7;
bool sum[N];
ll getsum(ll i,ll j) {
	if(i>j)swap(i,j);
	ll ans=0;
	for(ll k=j,q=0; k>=i; k--,q++) {
		ans+=(sum[k])*(1<<q);
	}
	return ans;
}
ll wes(unsigned ll x) {
	return 32-__builtin_clz(x);
}
//调试 
ll n,kk;
ll dp[N][N][1<<(K+1)|1];
ll str[1<<(K+1)|1];
bool tr[(1<<(K+1))|1];
int main() {
	cin>>n>>kk;
	for(ll i=1; i<=n; i++) {
		for(ll j=1; j<=n; j++) {
			for(ll s=(1<<kk)-1; s>=0; s--) {
				dp[i][j][s]=-1145141919810ll;//初始化 
			}
		}
	}
	for(ll i=1; i<=n; i++) {
		cin>>sum[i];
		dp[i][i][sum[i]]=0;
	}
	for(ll i=1; i<=(1<<kk); i++) {
		cin>>tr[i-1]>>str[i-1];
	}
	for(ll k=2; k<=n; k++) {
		for(ll i=1; i<=n-k+1; i++) {
			ll j=i+k-1;
			ll sizee=(k-1)%(kk-1);//
			if(sizee==0) {
				sizee=kk-1;
			}
			for(ll l=j-1; l>=i; l-=(kk-1)) {
				for(ll s=(1<<(sizee))-1; s>=0; s--) {
					dp[i][j][s<<1]=max(dp[i][j][s<<1],dp[i][l][s]+dp[l+1][j][0]);
					dp[i][j][s<<1|1]=max(dp[i][j][s<<1|1],dp[i][l][s]+dp[l+1][j][1]);
				}
			}
			if(sizee==kk-1) {
				ll r[2];
				r[0]=r[1]=-1145141919810ll;
				for(ll s=(1<<kk)-1; s>=0; s--) {
					r[tr[s]]=max(r[tr[s]],dp[i][j][s]+str[s]);
				}
				dp[i][j][0]=max(dp[i][j][0],r[0]);
				dp[i][j][1]=max(dp[i][j][1],r[1]);
			}
		}
	}
	ll ans=-1145141919810ll;
	for(ll s=(1<<kk)-1; s>=0; s--) {
		ans=max(ans,dp[1][n][s]);
	}
	cout<<ans<<endl;
}
```